[
    {
        "id": "mpi_allreduce_avg",
        "displayName": "Mpi Allreduce Avg",
        "dotImagePath": "shap_summary_mpi_allreduce_avg_dot.svg",
        "barImagePath": "shap_summary_mpi_allreduce_avg_bar.svg",
"description": "<p><strong>Analysis for MPI Allreduce Avg:</strong></p><p>This plot reveals features influencing the average MPI Allreduce time. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in Allreduce time, negative values a decrease. Overall, system contention (especially futex waiting) and CPU architecture (family and vendor) emerge as the primary drivers of average MPI Allreduce time.</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly increase the average Allreduce time. Lower values (blue dots) decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_6</code></strong>: The presence of this CPU family (red dots) significantly increases the average Allreduce time.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.vendor_id_Intel</code></strong>: Systems with this CPU vendor (red dots) tend to have higher average Allreduce times. Non-Intel systems (blue dots) show lower times.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) significantly decreases the average Allreduce time. Its absence (blue dots) leads to neutral or slightly higher times.</li><li><strong><code>num_cpu_waiting_ns</code></strong>: Higher values (red dots) increase the average Allreduce time.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) tends to decrease the average Allreduce time.</li><li><strong><code>num_cpu_running_ns</code></strong>: Higher values (red dots) are associated with increased average Allreduce times.</li></ul>"
    },
    {
        "id": "fom",
        "displayName": "Fom",
        "dotImagePath": "shap_summary_fom_dot.svg",
        "barImagePath": "shap_summary_fom_bar.svg",
        "description": "<p><strong>Analysis for FoM (Figure of Merit):</strong></p><p>This plot reveals features influencing the Figure of Merit (Fom). Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in Fom, while negative values show a decrease. Overall, Fom is now most significantly impacted by the number of threads (<code>num_threads</code>), with lower thread counts leading to higher Fom. System contention (<code>num_futex_waiting_ns</code>) and specific CPU characteristics also play key roles.</p><ul><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase Fom. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>num_futex_waiting_ns</code></strong>: Higher futex waiting times (red dots, indicating contention) generally decrease Fom. Lower futex waiting times (blue dots) tend toward neutral or slightly positive impacts.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase Fom.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it tends to decrease Fom. When disabled (blue dots), Fom is generally higher.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase Fom.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease Fom.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) tends to decrease Fom.</li></ul>"
    },
    {
        "id": "total_cg_iterations",
        "displayName": "Total Cg Iterations",
        "dotImagePath": "shap_summary_total_cg_iterations_dot.svg",
        "barImagePath": "shap_summary_total_cg_iterations_bar.svg",
        "description": "<p><strong>Analysis for Total CG Iterations:</strong></p><p>This plot reveals features influencing the total number of Conjugate Gradient (CG) iterations. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in iterations, while negative values show a decrease. Overall, CPU architecture (specific model IDs, family, and vendor) is the primary driver of CG iterations. System contention also plays a significant role.</p><ul><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) strongly decreases the total CG iterations. Its absence (blue dots) is associated with a higher number of iterations.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_6</code></strong>: The presence of this CPU family (red dots) strongly increases the total CG iterations.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.vendor_id_Intel</code></strong>: Systems with this CPU vendor (red dots) tend to have significantly more CG iterations. Non-Intel systems (blue dots) have fewer.</li><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) generally increase the number of CG iterations. Lower values (blue dots) are associated with fewer iterations.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_85</code></strong>: The presence of this CPU model ID (red dots) tends to increase CG iterations.</li><li><strong><code>num_cpu_waiting_ns</code></strong>: Higher waiting times (red dots) generally increase iteration counts.</li><li><strong><code>num_cpu_running_ns</code></strong>: Higher values (red dots) are associated with increased iteration counts.</li></ul>"
    },
    {
        "id": "memory_used_data_total_gbytes",
        "displayName": "Memory Used Data Total Gbytes",
        "dotImagePath": "shap_summary_memory_used_data_total_gbytes_dot.svg",
        "barImagePath": "shap_summary_memory_used_data_total_gbytes_bar.svg",
        "description": "<p><strong>Analysis for Memory Used Data Total GBytes:</strong></p><p>This plot reveals features influencing the total gigabytes of memory used by the data. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in memory used, while negative values show a decrease. Overall, system contention (<code>num_futex_waiting_ns</code>) and specific CPU model IDs are the most prominent factors influencing total memory usage. Other CPU architectural features also contribute.</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly increase total memory used. Lower values (blue dots) decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_17</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase total memory used.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase total memory used.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) tends to increase total memory used.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_85</code></strong>: The presence of this CPU model ID (red dots) tends to decrease total memory used.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) shows a tendency to decrease total memory used.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease total memory used.</li></ul>"
    },
    {
        "id": "memory_bandwidth_across_kernels_write",
        "displayName": "Memory Bandwidth Across Kernels Write",
        "dotImagePath": "shap_summary_memory_bandwidth_across_kernels_write_dot.svg",
        "barImagePath": "shap_summary_memory_bandwidth_across_kernels_write_bar.svg",
        "description": "<p><strong>Analysis for Memory Bandwidth Across Kernels Write:</strong></p><p>This plot reveals features influencing the memory write bandwidth across kernels. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in write bandwidth, while negative values show a decrease. Overall, memory write bandwidth is most significantly influenced by the number of threads (<code>num_threads</code>) and whether CPU hardware multithreading is enabled. Specific CPU model IDs and system contention also play important roles.</p><ul><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase memory write bandwidth. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it tends to decrease memory write bandwidth. When disabled (blue dots), write bandwidth is generally higher.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase memory write bandwidth.</li><li><strong><code>num_futex_waiting_ns</code></strong>: Higher futex waiting times (red dots, indicating contention) generally decrease memory write bandwidth. Lower futex waiting times (blue dots) tend toward neutral or slightly positive impacts.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase memory write bandwidth.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease memory write bandwidth.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) tends to decrease memory write bandwidth.</li></ul>"
},
    {
        "id": "gflops_per_second_ddot",
        "displayName": "Gflops Per Second Ddot",
        "dotImagePath": "shap_summary_gflops_per_second_ddot_dot.svg",
        "barImagePath": "shap_summary_gflops_per_second_ddot_bar.svg",
        "description": "<p><strong>Analysis for Gflops Per Second Ddot:</strong></p><p>This plot reveals features influencing the Gflops per second achieved by the Ddot kernel. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in Gflops, while negative values show a decrease. Overall, Gflops for Ddot are now primarily influenced by system contention (<code>num_futex_waiting_ns</code>) and specific CPU architectural details (family and model IDs).</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly decrease Ddot Gflops. Lower values (blue dots) increase it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_31</code></strong>: The presence of this CPU family (red dots) tends to increase Ddot Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_54273</code></strong>: The presence of this CPU model ID (red dots) also tends to increase Ddot Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a tendency to increase Ddot Gflops.</li><li><strong><code>num_cpu_running_ns</code></strong>: Higher CPU running times (red dots) tend to decrease Ddot Gflops. Lower running times (blue dots) tend to increase them.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) shows a slight tendency to increase Ddot Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_17</code></strong>: The presence of this CPU model ID (red dots) tends to decrease Ddot Gflops.</li></ul>"
    },
    {
        "id": "gflops_per_second_mg",
        "displayName": "Gflops Per Second Mg",
        "dotImagePath": "shap_summary_gflops_per_second_mg_dot.svg",
        "barImagePath": "shap_summary_gflops_per_second_mg_bar.svg",
        "description": "<p><strong>Analysis for Gflops Per Second Mg:</strong></p><p>This plot reveals features influencing the Gflops per second achieved by the Mg (Multigrid) kernel. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in Gflops, while negative values show a decrease. Overall, Gflops for Mg are now primarily influenced by system contention (<code>num_futex_waiting_ns</code>) and the number of threads (<code>num_threads</code>). Specific CPU characteristics also play a significant role.</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly decrease Mg Gflops. Lower values (blue dots) increase it.</li><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase Mg Gflops. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase Mg Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it tends to decrease Mg Gflops. When disabled (blue dots), Gflops are generally higher.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase Mg Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease Mg Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) tends to decrease Mg Gflops.</li></ul>"
    },
    {
        "id": "setup_time_seconds",
        "displayName": "Setup Time Seconds",
        "dotImagePath": "shap_summary_setup_time_seconds_dot.svg",
        "barImagePath": "shap_summary_setup_time_seconds_bar.svg",
        "description": "<p><strong>Analysis for Setup Time Seconds:</strong></p><p>This plot reveals features influencing the setup time in seconds. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in setup time, while negative values show a decrease. Overall, setup time is most significantly influenced by system contention (<code>num_futex_waiting_ns</code>) and various micro-architecture and CPU family characteristics.</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly increase setup time. Lower values (blue dots) decrease it.</li><li><strong><code>cat_micro_arch_O1</code></strong>: The presence of this micro-architecture optimization (red dots) tends to decrease setup time.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to decrease setup time.</li><li><strong><code>cat_micro_arch_Os</code></strong>: The presence of this micro-architecture optimization (red dots) tends to decrease setup time.</li><li><strong><code>cat_micro_arch_O2</code></strong>: The presence of this micro-architecture optimization (red dots) tends to decrease setup time.</li><li><strong><code>cat_micro_arch_Ofast</code></strong>: The presence of this micro-architecture optimization (red dots) tends to decrease setup time.</li><li><strong><code>cat_micro_arch_Og</code></strong>: The presence of this micro-architecture optimization (red dots) tends to decrease setup time.</li><li><strong><code>cat_micro_arch_O3</code></strong>: The presence of this micro-architecture optimization (red dots) tends to decrease setup time.</li></ul>"
    },
    {
        "id": "memory_bandwidth_across_kernels_read",
        "displayName": "Memory Bandwidth Across Kernels Read",
        "dotImagePath": "shap_summary_memory_bandwidth_across_kernels_read_dot.svg",
        "barImagePath": "shap_summary_memory_bandwidth_across_kernels_read_bar.svg",
        "description": "<p><strong>Analysis for Memory Bandwidth Across Kernels Read:</strong></p><p>This plot reveals features influencing the memory read bandwidth across kernels. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in read bandwidth, while negative values show a decrease. Overall, memory read bandwidth is most significantly influenced by system contention (<code>num_futex_waiting_ns</code>) and the number of threads (<code>num_threads</code>). Specific CPU characteristics and hardware multithreading also play important roles.</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly decrease memory read bandwidth. Lower values (blue dots) increase it.</li><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase memory read bandwidth. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase memory read bandwidth.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it tends to decrease memory read bandwidth. When disabled (blue dots), read bandwidth is generally higher.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase memory read bandwidth.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease memory read bandwidth.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) tends to decrease memory read bandwidth.</li></ul>"
    },
    {
        "id": "memory_bandwidth_across_kernels_total",
        "displayName": "Memory Bandwidth Across Kernels Total",
        "dotImagePath": "shap_summary_memory_bandwidth_across_kernels_total_dot.svg",
        "barImagePath": "shap_summary_memory_bandwidth_across_kernels_total_bar.svg",
        "description": "<p><strong>Analysis for Memory Bandwidth Across Kernels Total:</strong></p><p>This plot reveals features influencing the total memory bandwidth across kernels. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in total bandwidth, while negative values show a decrease. Overall, total memory bandwidth is most significantly influenced by the number of threads (<code>num_threads</code>) and system contention (<code>num_futex_waiting_ns</code>). Specific CPU characteristics and hardware multithreading also play important roles.</p><ul><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase total memory bandwidth. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase total memory bandwidth.</li><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly decrease total memory bandwidth. Lower values (blue dots) increase it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it tends to decrease total memory bandwidth. When disabled (blue dots), total bandwidth is generally higher.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase total memory bandwidth.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease total memory bandwidth.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) tends to decrease total memory bandwidth.</li></ul>"
    },
    {
        "id": "gflops_per_second_spmv",
        "displayName": "Gflops Per Second Spmv",
        "dotImagePath": "shap_summary_gflops_per_second_spmv_dot.svg",
        "barImagePath": "shap_summary_gflops_per_second_spmv_bar.svg",
        "description": "<p><strong>Analysis for Gflops Per Second Spmv:</strong></p><p>This plot reveals features influencing the Gflops per second achieved by the Spmv (Sparse Matrix-Vector Multiply) kernel. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in Gflops, while negative values show a decrease. Overall, Gflops for Spmv are now primarily influenced by system contention (<code>num_futex_waiting_ns</code>) and the number of threads (<code>num_threads</code>). Specific CPU characteristics also play a significant role.</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly decrease Spmv Gflops. Lower values (blue dots) increase it.</li><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase Spmv Gflops. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase Spmv Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it tends to decrease Spmv Gflops. When disabled (blue dots), Gflops are generally higher.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase Spmv Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease Spmv Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) tends to decrease Spmv Gflops.</li></ul>"
    },
    {
        "id": "mpi_allreduce_max",
        "displayName": "Mpi Allreduce Max",
        "dotImagePath": "shap_summary_mpi_allreduce_max_dot.svg",
        "barImagePath": "shap_summary_mpi_allreduce_max_bar.svg",
        "description": "<p><strong>Analysis for MPI Allreduce Max:</strong></p><p>This plot reveals features influencing the maximum time taken for MPI Allreduce operations. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in the maximum Allreduce time, while negative values show a decrease. Overall, maximum Allreduce time is heavily influenced by CPU architecture (family and vendor) and system contention (primarily futex waiting time).</p><ul><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) strongly decreases the maximum Allreduce time. Its absence (blue dots) is associated with significantly higher maximum times.</li><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly increase the maximum Allreduce time. Lower values (blue dots) decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_6</code></strong>: The presence of this CPU family (red dots) tends to increase the maximum Allreduce time.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.vendor_id_Intel</code></strong>: Systems with this CPU vendor (red dots) tend to have considerably higher maximum Allreduce times. Non-Intel systems (blue dots) show lower maximum times.</li><li><strong><code>num_cpu_waiting_ns</code></strong>: Higher values (red dots) increase the maximum Allreduce time.</li><li><strong><code>num_cpu_running_ns</code></strong>: Higher values (red dots) are associated with increased maximum Allreduce times.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) tends to decrease the maximum Allreduce time.</li></ul>"    },
    {
        "id": "duration",
        "displayName": "Duration",
        "dotImagePath": "shap_summary_duration_dot.svg",
        "barImagePath": "shap_summary_duration_bar.svg",
        "description": "<p><strong>Analysis for Duration:</strong></p><p>This plot reveals features influencing the overall execution duration. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in duration, while negative values show a decrease. Overall, duration is most significantly impacted by system contention (futex, CPU waiting, and CPU running times). Specific CPU model IDs and optimizations also show some influence.</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly increase duration. Lower values (blue dots) decrease it.</li><li><strong><code>num_cpu_waiting_ns</code></strong>: Higher values (red dots) increase duration.</li><li><strong><code>num_cpu_running_ns</code></strong>: Higher values (red dots) are associated with increased duration.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_85</code></strong>: The presence of this CPU model ID (red dots) tends to decrease duration.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) tends to increase duration.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.vendor_id_Intel</code></strong>: Systems with this CPU vendor (red dots) tend to have slightly longer durations.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_6</code></strong>: The presence of this CPU family (red dots) tends to increase duration.</li></ul>"
    },
    {
        "id": "mpi_allreduce_min",
        "displayName": "Mpi Allreduce Min",
        "dotImagePath": "shap_summary_mpi_allreduce_min_dot.svg",
        "barImagePath": "shap_summary_mpi_allreduce_min_bar.svg",
        "description": "<p><strong>Analysis for MPI Allreduce Min:</strong></p><p>This plot reveals features influencing the minimum time taken for MPI Allreduce operations. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in the minimum Allreduce time, while negative values show a decrease. Overall, minimum Allreduce time is primarily influenced by system contention (futex and CPU waiting times) and CPU architecture (family and vendor).</p><ul><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly increase the minimum Allreduce time. Lower values (blue dots) decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) significantly decreases the minimum Allreduce time. Its absence (blue dots) leads to neutral or slightly higher times.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.vendor_id_Intel</code></strong>: Systems with this CPU vendor (red dots) tend to have higher minimum Allreduce times. Non-Intel systems (blue dots) show lower times.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_6</code></strong>: The presence of this CPU family (red dots) tends to increase the minimum Allreduce time.</li><li><strong><code>num_cpu_waiting_ns</code></strong>: Higher values (red dots) increase the minimum Allreduce time.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) tends to decrease the minimum Allreduce time.</li><li><strong><code>num_cpu_running_ns</code></strong>: Higher values (red dots) are associated with increased minimum Allreduce times.</li></ul>"
    },
    {
        "id": "gflops_per_second_waxpby",
        "displayName": "Gflops Per Second Waxpby",
        "dotImagePath": "shap_summary_gflops_per_second_waxpby_dot.svg",
        "barImagePath": "shap_summary_gflops_per_second_waxpby_bar.svg",
         "description": "<p><strong>Analysis for Gflops Per Second Waxpby:</strong></p><p>This plot reveals features influencing the Gflops per second achieved by the Waxpby kernel. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in Gflops, while negative values show a decrease. Overall, Gflops for Waxpby are now primarily influenced by whether CPU hardware multithreading is enabled, system contention (<code>num_futex_waiting_ns</code>), and the number of threads (<code>num_threads</code>). Specific CPU characteristics also play a significant role.</p><ul><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it strongly decreases Waxpby Gflops. When disabled (blue dots), Gflops are significantly higher.</li><li><strong><code>num_futex_waiting_ns</code></strong>: Higher values (red dots, indicating contention) strongly decrease Waxpby Gflops. Lower values (blue dots) increase it.</li><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase Waxpby Gflops. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_106</code></strong>: The presence of this CPU model ID (red dots) shows a strong tendency to increase Waxpby Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase Waxpby Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_63</code></strong>: The presence of this CPU family (red dots) tends to decrease Waxpby Gflops.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_53441</code></strong>: The presence of this CPU model ID (red dots) tends to decrease Waxpby Gflops.</li></ul>"
    },
    {
        "id": "fom_per_dollar",
        "displayName": "Fom Per Dollar",
        "dotImagePath": "shap_summary_fom_per_dollar_dot.svg",
        "barImagePath": "shap_summary_fom_per_dollar_bar.svg",
        "description": "<p><strong>Analysis for FoM Per Dollar:</strong></p><p>This plot reveals features influencing the Figure of Merit (Fom) per Dollar. Red dots signify high feature values, blue dots low values. Positive SHAP values (right of center) indicate an increase in Fom per Dollar, while negative values show a decrease. Overall, Fom per Dollar is most strongly influenced by the number of threads (<code>num_threads</code>) and whether CPU hardware multithreading is enabled. System contention and specific CPU characteristics also play a role.</p><ul><li><strong><code>num_threads</code></strong>: Lower numbers of threads (blue dots) strongly increase Fom per Dollar. Higher numbers of threads (red dots) strongly decrease it.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-hardware_multithreading_true</code></strong>: When CPU hardware multithreading is enabled (red dots), it tends to decrease Fom per Dollar. When disabled (blue dots), Fom per Dollar is generally higher.</li><li><strong><code>num_futex_waiting_ns</code></strong>: Higher futex waiting times (red dots, indicating contention) generally decrease Fom per Dollar. Lower futex waiting times (blue dots) tend toward neutral or slightly positive impacts.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.family_25</code></strong>: The presence of this CPU family (red dots) tends to increase Fom per Dollar.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.vendor_id_ARM</code></strong>: The presence of this CPU vendor (red dots) tends to increase Fom per Dollar.</li><li><strong><code>num_cpu_running_ns</code></strong>: Higher CPU running times (red dots) show a tendency to decrease Fom per Dollar.</li><li><strong><code>cat_feature.node.kubernetes.io/cpu-model.id_85</code></strong>: The presence of this CPU model ID (red dots) tends to increase Fom per Dollar.</li></ul>"
    }
]
